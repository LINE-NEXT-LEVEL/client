import { Code } from '../../../src/components/Code';
import { Challenge, CHallengeList, DetailButton } from '../../../src/components/Challenge';
import { Flex } from '../../../src/components/Flex';

# 객체인 상태를 업데이트하기

상태는 모든 종류의 JavaScript 값을 가질 수 있습니다. 하지만 React 상테가 갖고 있는 객체를 직접적으로 변경해서는 안됩니다. 대신, 객체를 업데이트하고 싶을 때는 새 객체를 만들어야(또는 기존에 있는 객체의 복사본을 만들거나) 합니다.
그리고 나서 그 복사본을 사용해 상태를 설정해야 합니다. 

:::note You will learn

- React 상태인 객체를 올바르게 업데이트하는 방법
- 객체를 변형하지 않고 중첩된 객체를 업데이트하는 방법
- 불변성이란 무엇인지, 그리고 불변성을 깨뜨리지 않는 방법
- Immer를 사용해 객체를 덜 반복해서 복사하는 방법
:::

## mutation(변화)이란?

모든 종류의 JavaScript값을 상태로 저장할 수 있습니다

```js
const [x, setX] = useState(0);
```

이 때까지 number, string, boolean 값으로 작업해왔습니다. 이 JavaScript값들은 "불변"합니다. "불변"하다는 것은 바꿀 수 없거나 "읽기 전용"이라는 의미입니다. 값을 _교체_하기 위해 다시 렌더링을 할 수 있습니다:

```js
setX(5);
```

`x`상태는 `0`에서 `5`로 변했습니다. 하지만 숫자 `0` _그 자체_는 변하지 않았습니다. JavaScript의 number, string, boolean과 같이 내장된 원시적인 값을 변경할 수는 없습니다. 

이제 상태로 객체를 고려해보세요:

```js
const [position, setPosition] = useState({ x: 0, y: 0 });
```

엄밀히 말해서, _객체 그 자체_의 내용을 바꾸는 것은 가능합니다. **이것을 mutation이라고 부릅니다:**

```js
position.x = 5;
```

그러나, 리액트 상태로의 객체가 원칙적으로는 mutable(가변적)임에도 불구하고, 객체가 불변적인 것*처럼* 취급해야 합니다-number,string처럼요. 객체를 변경하는 대신에, 항상 교체해야 합니다.

## 상태를 읽기 전용으로 취급하기

다른 말로, 항상 *상태로 사용하는 JavaScript 객체를 읽기 전용으로 다루어야 합니다.*

이 예시는 현재의 포인터 위치를 표현하기 위해 상태로 객체를 사용합니다. 원래라면 미리보기 영역에서 빨간 점을 건드리거나 커서를 움직이면 빨간 점도 같이 움직이게 되어있습니다. 하지만 점이 최초의 지점에 계속 머물러 있습니다:

<Code src='https://codesandbox.io/s/lindzn?file=%2FApp.js&utm_medium=sandpack'/>

코드에 약간의 문제가 있습니다.

```js
onPointerMove={e => {
  position.x = e.clientX;
  position.y = e.clientY;
}}
```

이 코드는 [이전의 렌더링](https://beta.reactjs.org/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time)에서 `position`에 할당된 객체를 변경시킵니다. 하지만 상태 설정 함수를 사용하지 않으면,
리액트는 그 객체가 변화했는지 알 수 없습니다. 그래서 리액트가 아무것도 반응하지 않는 것입니다. 이것은 식사를 마치고 나서 주문을 변경하려고 하는 것과 같은 것입니다.
상태를 변화시키는 것은 몇 가지 케이스에서 작동할 수 있지만, 권장하는 방법은 아닙니다. 렌더링할 때는 접근하는 상태값을 읽기 전용으로 취급해야 합니다.

실제로 이 경우에 [새로 렌더링을 일으키기](https://beta.reactjs.org/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time) 위해서는 *_새_ 객체를 만들고 새 객체를 상태 설정 함수로 넘겨주어야 합니다:*

```js
onPointerMove={e => {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}
```

`setPosition`을 사용하면 리액트에 이렇게 말하는 것입니다:

- 새 객체로 `position`을 교체해라
- 이 컴포넌트를 다시 렌더링해라

미리보기 영역을 클릭하거나 위에 마우스를 위치시키면 빨간 점이 포인터를 따라간다는 것을 확인할 수 있습니다:

<Code src="https://codesandbox.io/s/dqdjes?file=%2FApp.js&utm_medium=sandpack"/>

:::info DEEP DIVE

### 지역적인 변화는 괜찮습니다. 

이와 같은 코드의 문제는 이 코드가 상태로 사용되는 _존재하는_ 객체를 변형시킨다는 점입니다:

```js
position.x = e.clientX;
position.y = e.clientY;
```

:::

하지만 이 코드는 _방금 생성된_ 새 객체를 변형시키기 때문에 *완전히 괜찮습니다.*:

```js
const nextPosition = {};
nextPosition.x = e.clientX;
nextPosition.y = e.clientY;
setPosition(nextPosition);
```

사실, 이렇게 적는 것과 완전히 같기도 합니다:

```js
setPosition({
  x: e.clientX,
  y: e.clientY
});
```

가변성은 이미 상태로 _존재하는_객체를 변경할 때만 문제가 됩니다. 방금 생성한 객체를 변경하는 것은 _그 객체를 참조하는 코드가 없기_ 때문에 괜찮습니다.
방금 새로만든 객체를 변경하는 것은 그것에 의존하는 무언가에 우연히 영향을 미치지 않을 것입니다. 이것을 "지역 mutation"이라고 부릅니다. 
[렌더링 하는 동안](https://beta.reactjs.org/learn/keeping-components-pure#local-mutation-your-components-little-secret)에도 지역 mutation은 가능합니다. 엄청 편리하고 완전히 괜찮죠!

:::

## spread 문법으로 객체 복사하기

이전의 예시에서, `position`객체는 항상 현재 커서 위치에서 새롭게 갱신되어 만들어졌습니다. 하지만, 종종 _이미 존재하는_데이터를 포함해서 새로운 객체를 만들고 싶을 수도 있습니다. 
예를 들어, 형식에서 _단 한_ 필드만 업데이트하고 다른 필드는 이전 값들을 유지하고 싶을 수도 있습니다. 

이 입력 필드는 `onChange` 핸들러가 상태를 변경하기 때문에 동작하지 않습니다:

<Code src="https://codesandbox.io/s/ex76lb?file=/App.js&utm_medium=sandpack"/>

예를 들어, 이 줄의 코드는 과거의 렌더링에서 상태를 변경합니다:

```js
person.firstName = e.target.value;
```

기대하는 행동을 얻는 안정적인 방법은 새 객체를 만들고 새로운 객체를 `setPerson`으로 넘기는 것입니다. 하지만 여기서 하나의 필드만 변하기 때문에 *이미 있는 데이터도 새 객체에 복사*하고 싶을 수 있습니다:

```js
setPerson({
  firstName: e.target.value, // New first name from the input
  lastName: person.lastName,
  email: person.email
});
```

[객체 spread](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals)를 사용하면 모든 객체의 특성들을 개별적으로 복사할 필요가 없습니다.

```js
setPerson({
  ...person, // Copy the old fields
  firstName: e.target.value // But override this one
});
```

이제 form이 동작합니다!
각 입력 필드에 각각의 상태변수를 선언하지 않았다는 것을 확인해보세요. 큰 형식을 사용할 때, 한 객체에 모든 데이터를 그룹으로 만들어서 유지하는 것은 매우 편리합니다 - 정확히 업데이트하는 한 말입니다!

<Code src="https://codesandbox.io/s/8t5lq9?file=/App.js&utm_medium=sandpack"/>

`...`spread 문법은 "얕은"복사입니다. - 이 문법은 복사할 때 한 단계의 깊이만 복사합니다. 빠르지만, 중첩된 값들을 업데이트하길 원할 때, 한 번 이상 사용해야 할 것입니다. 

:::info DEEP DIVE

### 여러개의 필드에 하나의 이벤트 핸들러 사용하기

동적인 값을 가진 키를 명시하기 위해 객체 선언 안에 `[``]` 괄호를 사용할 수 있습니다. 여기 세개의 다른 이벤트 핸들러 대신 하나만을 사용한 같은 예시가 있습니다. 

<Code src="https://codesandbox.io/s/59hnw3?file=/App.js&utm_medium=sandpack"/>

여기, `e.target.name`은 DOM 요소의 `<input>`에 주어진 `name` 특성을 가리킵니다. 

:::

## 중첩된 객체 업데이트하기 

이와 같은 중첩된 객체 구조를 고려해보세요:

```js
const [person, setPerson] = useState({
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  }
});
```
만약 `person.artwork.city`를 업데이트하길 원하면 어떻게 변경을 시킬지는 명확합니다:

```js
person.artwork.city = 'New Delhi';
```

하지만 React에서는, 상태를 불변하는 것으로 취급해야해요! `city`를 변경하기 위해서, (이전의 것에서 데이터를 미리 채워놓은) 새로운 `artwork` 객체를 만들 필요가 있을 것입니다, 그리고 나서 
새로운 `artwork`를 가리키는 새로운 `person` 객체를 만들어냅니다:

```js
const nextArtwork = { ...person.artwork, city: 'New Delhi' };
const nextPerson = { ...person, artwork: nextArtwork };
setPerson(nextPerson);
```

또는, 하나의 함수 호출로 적힐 수도 있습니다:

```js
setPerson({
  ...person, // Copy other fields
  artwork: { // but replace the artwork
    ...person.artwork, // with the same one
    city: 'New Delhi' // but in New Delhi!
  }
});
```

조금 장황하긴 하지만, 많은 케이스에서 잘 작동합니다:

<Code src="https://codesandbox.io/s/qczu11?file=/App.js&utm_medium=sandpack"/>

:::info DEEP DIVE

### 객체가 정말로 중첩된 것은 아닙니다

이런 객체는 코드에서 "중첩된" 것처럼 보입니다:

```js
let obj = {
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  }
};
```

그러나, "중첩"은 객체가 어떻게 행동하는지를 생각하기에는 부정확한 방법입니다. 코드가 작동할 떄, "중첩된" 객체 같은 것은 없습니다. 여러분은 두개의 다른 객체를 보고 있습니다:

```js
let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1
};
```
`obj1`는`objk2`"안에" 있는 것이 아닙니다. 예를 들어, `obj3`도 `obj1`를 "가리킬" 수 있습니다:

```js
let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1
};

let obj3 = {
  name: 'Copycat',
  artwork: obj1
};
```

만약 `obj3.artwork.city`를 업데이트하려고 한다면,`obj2.artwork.city`와`obj1.city` 둘 다에 영향을 미칠 것입니다.
왜냐하면 `obj3.artwork`,`obj2.artwork`,`obj1`은 모두 같은 객체이기 때문입니다. 이 점은 객체를 "중첩된" 것으로 생각한다면 보기 어려운 부분입니다.
대신, 세 객체들은 서로를 키로 "가리키고" 있는 각각의 분리된 객체입니다.

:::

## Immer를 사용해 간결한 업데이트 로직을 작성하기

만약 상태가 깊게 중첩되어있다면, [객체를 납작하게 만드는 것](https://beta.reactjs.org/learn/choosing-the-state-structure#avoid-deeply-nested-state)을 고려할수도 있습니다.
하지만, 만약 상태구조를  변경하고 싶지 않다면, 중첩된 spread 지름길을 선호할 수 있습니다.
[Immer](https://github.com/immerjs/use-immer)는 편리하지만 변경하는 문법을 사용하여 코드를 작성하도록 해 주고, 여러분을 위해 복사본 생성을 관리해주는 인기있는 라이브러리 입니다.
Immer를 사용하면, 작성한 코드는 "문법을 어기고" 객채를 변경하는 것처럼 보입니다:

```js
updatePerson(draft => {
  draft.artwork.city = 'Lagos';
});
```

하지만, 일반적인 mutation과 다르게, 과거의 상태를 덮어쓰지 않습니다!

:::info DEEP DIVE

### Immer는 어떻게 작용하나요?

Immer가 제공하는 `draft`는 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)라고 불리는 동작을 "기록"하는 특별한 타입의 객체입니다.
이 특징이 원하는 만큼 그 객체를 자유롭게 변형할 수 있는 이유입니다! 내부에서는, Immer가 `draft`의 어떤 부분이 변경되었는지를 알아냅니다.
그리고, 수정된 부분을 포함하여 완전히 새로운 객체를 생성해닙니다.

:::

Immer를 사용해보기:

1. `package.json`에 `use-immer`를 의존성으로 추가합니다
2. `npm install`을 실행합니다.
3. `import { useState } from 'react'`를`import { useImmer } from 'use-immer'`로 교체합니다.

Immer로 변경된 위의 예제입니다:

<Code src="https://codesandbox.io/s/vr01ks?file=/App.js&utm_medium=sandpack"/>

이벤트핸들러가 얼마다 더 간결해졌는지 확인해보세요. 한 컴포넌트 안에 `useState`와`useImmer`를 원하는 만큼 섞어 사용할 수도 있습니다.
Immer는 업데이트 핸들러를 간결하게 유지하는 좋은 방법입니다. 특히, 만약 상태 안에 중첩이 있고 객체를 복사하는게 반복되는 코드를 생성한다면 더욱 그렇습니다.

:::info DEEP DIVE

### 왜 상태를 변경하는 것은 React에서 권장되지 않나요?

몇 가지 이유가 있습니다:

- **디버깅:** 만약 `console.log`를 사용하고 상태를 변경하지 않는다면, 과거의 로그들은 더 최근의 상태 변화에 훼손되지 않을 것입니다.
그래서 상태가 렌더링 사이에 어떻게 변했는지 분명하게 확인할 수 있습니다. 
- **최적화:** 일반적인 React의 [최적화 전략](https://beta.reactjs.org/apis/react/memo)은 이전의 prop이나 상태가 다음의 것과 같으면 작업을 생략하는 것에 의존합니다.
만약 상태를 전혀 변경하지 않는다면, 변화가 있었는지 여부를 매우 빨리 확인할 수 있습니다.
만약 `prevObj === obj`라면, 내부가 아무것도 바뀌지 않았다는 것을 확신할 수 있습니다.
- **새 특성들:** 지금 만들어나가고 있는 React의 새로운 특징은 상태가 [스냅샷처럼 사용되는 것](https://beta.reactjs.org/learn/state-as-a-snapshot)에 의존하고 있습니다. 
만약 상태의 과거 버전들을 변경한다면, 새로운 특성들을 사용하지 못할 수 있습니다.
- **필수 변화:** 되돌리기/다시 하기를 이용하는 것, 변화 내역을 보여주는 것, 혹은 사용자가 이전의 값으로 form을 리셋하는 것과 같은 앱상의 기능들은 아무것도 변경되지 았았을 때 더 구현하기 쉽습니다.
메모리 안에 상태의 과거의 복사본들을 유지하고, 적절한 때에 그것들을 사용할 수 있기 때문입니다.
변경이 되는 접근으로 시작한다면, 이와 같은 기능들은 나중에 추가하기 어려워질 수 있습니다.
- **더 간단한 구현:** React는 mutation에 의존하지 않기 때문에, 객체로 어떤 특별한 일을 할 필요가 없습니다.
많은 "반응형" 솔루션이 하는 것처럼 속성을 가로채거나, 항상 프록시로 감싸거나, 다른 특성들을 사용할 필요가 없습니다. 
따라서 React를 사용하면 추가 성능이나 정확성이 저하되지 않고 크기에 상관없이 모든 개체를 상태로 전환할 수 있습니다.   

:::info

## 되짚어보기

- 모든 React의 상태를 불변적인 것으로 취급하세요.
- 상태에 객체를 저장할 떄, 객체를 변경하는 것은 렌더링을 잃으키지 않고 이전의 렌더링 "스냅샷"과 다른 상태를 만들것입니다. 
- 객체를 변경하는 대신에, _새로운_버전의 객체를 만들고 새로운 객체에 정보를 저장해 다시 렌더링을 유발하세요.
- 객체를 복사하기 위해 `{...obj, something: 'newValue'}`와 같은 객체 spread 문법을 사용할 수 있습니다.
- spread 문법은 얕은 복사입니다. 그것은 하나의 깊이만을 복사합니다. 
- 중첩된 객체를 복사하기 위해서는 업데이트하려는 위치의 가장 위쪽까지 복사본을 만들어야 합니다.
- 반복되는 복사코드를 줄이려면 Immer를 사용하세요.

<ChallengeList titleList="hello,hello,hello"/>
<ChallengeList titleList="Update an item in the shopping cart,Remove an item from the shopping cart,Fix the mutations using non-mutative methods,Fix the mutations using Immer">
<Challenge title="잘못된 상태 업데이트 수정하기" index={1}>
이 form은 몇가지 버그를 갖고 있습니다. 점수를 높이는 버튼을 몇 번 클릭해보세요. 올라가지 않는 것을 확인할 수 있습니다. 그리고나서 이름(first name)을 수정하면, 수정했을 떄 점수가 갑자기 "따라잡힌" 것을 확인할 수 있습니다.
마지막으로, 성을 수정하면 점수가 완전히 사라진 것을 확인할 수 있습니다.

모든 버그를 고쳐보세요. 수정하고 왜 각각의 버그가 일어났는지 설명해주세요.

<Code src="https://codesandbox.io/s/cp0jlx?file=%2FApp.js&utm_medium=sandpack"/>
<DetailButton name="해답">
여기 두 버그가 고쳐진 버전이 있습니다:
<Code src="https://codesandbox.io/s/gv1gj7?file=%2FApp.js&utm_medium=sandpack"/>
`handlePlusClick`의 문제는 `player` 객체를 변경한다는 것입니다. 결과적으로 React는 리랜더링을 시킬 이유를 물랐고, 화면상의 점수를 업데이트하지 않았습니다. 이름을 수정했을 떄 상태가 업데이트 되면서 화면의 점수를 같이 업데이트하는 리렌더링이 일어난 이유입니다.

`handleLastNameChange`의 문제는 이미 있는 `...player`필드를 새로운 객체로 카피하지 않았던 것입니다. 그렇기 때문에 성(last name)을 수정하고 나서는 점수가 사라졌습니다.
</DetailButton>
</Challenge>
<Challenge title="mutation을 찾아서 고치기" index={2}>
고정된 배경에 드래그할 수 있는 박스가 있습니다. select input을 이용해 박스의 색상을 변경할 수 있습니다.

하지만 버그가 하나 있습니다. 박스를 먼저 움직이고 나서 색상을 변경하면 배경이(원래는 움직이면 안됩니다!) 박스의 위치로 "뛰어"올 것입니다.
하지만 이건 일어나면 안됩니다: `background`의 `position` prop은 `initialPosition`에 고정되어있고, `{x: 0,y: 0}`입니다.
왜 생상을 변경하면 배경이 움직일까요?

<Code src="https://codesandbox.io/s/cgol6p?file=%2FApp.js&utm_medium=sandpack"/>
<Flex>
<DetailButton name="힌트">
예상하지 못한 변화가 있다면 mutation이 있다는 것입니다. `App.js`에서 mutation을 찾고 수정해보세요.
</DetailButton>
<DetailButton name="해답">
문제는 `handleMove` 안의 mutation에 있었습니다. 이 mutation은 `initialPosition`이 가리키는 같은 객체인 `shape.position`을 변경했습니다. 
이 부분이 왜 색상과 배경이 같이 움직였는지에 대한 이유입니다. (mutation이기 때문에 리랜더링을 유발하는 색상 변화 - 관련되지 않은 업데이트가 일어날 때까지 반영되지 않았습니다.)

`handleMove`에서 mutation을 수정하고, 모양을 카피하는 스프레드 문법을 사용합니다. `+=` 또한 mutation인 것을 확인하세요. 그래서 일반적인 `+`를 사용해 다시 써야 합니다.
<Code src="https://codesandbox.io/s/vbcoe2?file=%2FApp.js&utm_medium=sandpack"/>
</DetailButton>
</Flex>
</Challenge>
<Challenge title="Immer를 사용해 객체 업데이트하기" index={3}>
이전의 챌린지에서 보았던 같은 버그 예시입니다. 이번에는 Immer를 사용해서 수정해보세요. 편리하게 `useImmer`는 이미 import되어있습니다.
그래서 그것을 사용해 `shape` 상태변수를 변경할 필요가 있습니다. 
<DetailButton name="해답">
Immer로 다시 쓰여진 해답입니다. 이벤트 핸들러들이 mutate하는 형식으로 쓰여졌지만, 버그는 일어나지 않는다는 것을 확인해보세요. 
물밑에서 Immer가 존재하는 객체를 절대 변경하지 않기 떄문에 그렇습니다.
<Code src="https://codesandbox.io/s/ecqgpw?file=%2FApp.js&utm_medium=sandpack"/>
</DetailButton>
</Challenge>
</ChallengeList>



