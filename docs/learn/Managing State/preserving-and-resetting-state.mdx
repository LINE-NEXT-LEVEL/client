import { Code } from '../../../src/components/Code';
import { CenterImage } from "../../../src/components/CenterImage/CenterImage"; import {
    BlockQuote
} from "../../../src/components/BlockQuote/BlockQuote";

# 상태를 유지하고 재설정하는 방법

상태는 컴포넌트에 담긴 채로 격리되어 있습니다. React는 UI 트리에 기반해 어떤 상태가 어떤 컴포넌트의 것인지를 끊임 없이 추적합니다.
리렌더링이 일어나는 동안, 여러분은 상태를 유지하거나 초기화하는 등의 조작을 할 수 있습니다.

:::info 여러분이 배울 것
- 어떻게 React가 컴포넌트의 구조를 "보는지"
- React가 상태를 유지하거나 초기화하는 것을 언제 선택하는지
- React의 상태를 어떻게 강제로 초기화시키는지
- Key와 type이 상태 보존 여부에 미치는 영향
:::

## UI 트리

브라우저는 UI를 모델링 할 때 많은 트리 구조를 이용합니다. [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction)은 HTML 엘리먼트들을 대표하고,
[CSSOM](https://developer.mozilla.org/docs/Web/API/CSS_Object_Model)은 CSS를 표현하는 트리 모델입니다.
[Accessibility tree](https://developer.mozilla.org/docs/Glossary/Accessibility_tree)라는 것도 있습니다!

React도 트리 구조를 이용해 여러분이 만든 UI를 구조화하고 관리합니다. React는 JSX로부터 **UI 트리**를 만듭니다.
그리고 React DOM은 그 UI 트리에 맞게 브라우저의 DOM 엘리먼트들을 업데이트합니다. (React Native는 그 트리를 모바일 플랫폼에 맞는 특정 엘리먼트로 번역합니다.)

<CenterImage
    src="https://beta.reactjs.org/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_dom_tree.dark.png&w=1920&q=75"
    alt="Diagram with three sections arranged horizontally. In the first section, there are three rectangles stacked vertically, with labels 'Component A', 'Component B', and 'Component C'. Transitioning to the next pane is an arrow with the React logo on top labeled 'React'. The middle section contains a tree of components, with the root labeled 'A' and two children labeled 'B' and 'C'. The next section is again transitioned using an arrow with the React logo on top labeled 'React'. The third and final section is a wireframe of a browser, containing a tree of 8 nodes, which has only a subset highlighted (indicating the subtree from the middle section)."
/>

React는 컴포넌트로부터 UI 트리를 만들고, React DOM이 이 트리를 DOM을 렌더링할 때 이용합니다.

## 상태는 트리의 위치에 묶여있습니다.

만약 컴포넌트에 상태가 주어지면, 여러분은 아마 그 상태가 컴포넌트 안에서 "살아있다고" 생각할 수도 있습니다.
그치만 상태는 실제로 각 컴포넌트가 아닌 React가 들고 있습니다. React는 컴포넌트가 UI 트리 상의 위치에 상태 조각들을 연관짓습니다.

아래 예시에는 `<Counter />` JSX 태그가 하나만 존재합니다. 그치만 두 개의 다른 위치에 렌더링 됩니다.

<Code src="https://codesandbox.io/embed/musing-mountain-3f7gzd?fontsize=14&hidenavigation=1&theme=dark" />

이것이 나무처럼 보이는 이유는 다음과 같습니다.

<CenterImage
    src="https://beta.reactjs.org/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_tree.dark.png&w=828&q=75"
    alt="Diagram of a tree of React components. The root node is labeled 'div' and has two children. Each of the children are labeled 'Counter' and both contain a state bubble labeled 'count' with value 0."
/>

**두 개의 카운터는 트리 상 서로 다른 두 위치에서 렌더링 되었기 때문에 분리되었습니다.**
실제로 React를 사용할 때는 이 부분에 대해 생각해볼 필요가 없지만, 동작 과정을 이해하는데 있어서는 유용합니다.

React에서 화면에 그려지는 서로 다른 컴포넌트는 완벽하게 격리된 상태를 각각 가집니다. 예를 들어, 만약 여러분이 두 개의 `Counter` 컴포넌트를 연달아 만들었다면,
각 컴포넌트는 각각의 `score`와 `hover` 상태를 가집니다.

두 카운터를 각각 클릭해보고 서로에게 영향이 가는지 확인해보세요.

<Code src="https://codesandbox.io/embed/blazing-darkness-ls5jwy?fontsize=14&hidenavigation=1&theme=dark" />

아마 확인하셨겠지만, 하나의 카운터가 업데이트 되면 그 카운터의 상태만 업데이트 됩니다.

<CenterImage
    src="https://beta.reactjs.org/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_increment.dark.png&w=1080&q=75"
    alt="Diagram of a tree of React components. The root node is labeled 'div' and has two children. The left child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is labeled 'Counter' and contains a state bubble labeled 'count' with value 1. The state bubble of the right child is highlighted in yellow to indicate its value has updated."
/>

React는 같은 자리에서 동일한 컴포넌트가 렌더링 되는 동안은 계속 상태를 관리합니다.
아래 예시에서 두 카운터를 동시에 증가시키고, "Render the second counter" 체크박스를 해제해서 두 번째 카운터를 없앤 다음, 다시 체크박스를 클릭해 이를 확인해볼 수 있습니다.

<Code src="https://codesandbox.io/embed/practical-bas-o5qxmg?fontsize=14&hidenavigation=1&theme=dark" />

두 번째 카운터의 렌더링을 멈추었을 때를 주목해보세요. 그 컴포넌트의 상태는 완전히 사라졌습니다.
이는 React가 컴포넌트를 삭제함과 동시에 관리되던 상태도 제거했기 때문입니다.

<CenterImage
    src="https://beta.reactjs.org/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_remove_component.dark.png&w=1080&q=75"
    alt="Diagram of a tree of React components. The root node is labeled 'div' and has two children. The left child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is missing, and in its place is a yellow 'poof' image, highlighting the component being deleted from the tree."
/>

컴포넌트를 삭제하는 경우

만약 "Render the second counter"를 다시 클릭할 경우, 두 번째 `Counter`와 그의 상태는 다시 처음부터 시작합니다(`score = 0`). 그리고 DOM에 추가됩니다.

<CenterImage
    src="https://beta.reactjs.org/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_add_component.dark.png&w=1080&q=75"
    alt="Diagram of a tree of React components. The root node is labeled 'div' and has two children. The left child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The entire right child node is highlighted in yellow, indicating that it was just added to the tree."
/>

컴포넌트를 다시 추가하는 경우

**React는 컴포넌트의 상태를 컴포넌트가 UI 트리 상에서 위치하는 동안에는 계속 상태를 보존합니다.** 만약 컴포넌트가 UI 트리에서 지워질 경우나 다른 컴포넌트가 같은 위치에 새로 그려지는 경우라면 React는 관리하던 상태를 없앱니다.


## 같은 위치에 그려지는 같은 컴포넌트는 상태가 유지됩니다.

아래 예시에 두 개의 `<Counter />` 태그가 있습니다.

<Code src="https://codesandbox.io/embed/immutable-forest-q77znv?fontsize=14&hidenavigation=1&theme=dark" />

체크박스를 클릭해 체크하거나 체크를 해제하더라도 카운터의 상태는 초기화되지 않습니다.
`isFancy`가 `true`인지 `false`인지에 상관 없이 여러은 항상 `App` 컴포넌트의 첫 번째 자식은 항상 `<Counter />`입니다.

<CenterImage
    src="https://beta.reactjs.org/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_same_component.dark.png&w=1200&q=75"
    alt="Diagram with two sections separated by an arrow transitioning between them. Each section contains a layout of components with a parent labeled 'App' containing a state bubble labeled isFancy. This component has one child labeled 'div', which leads to a prop bubble containing isFancy (highlighted in purple) passed down to the only child. The last child is labeled 'Counter' and contains a state bubble with label 'count' and value 3 in both diagrams. In the left section of the diagram, nothing is highlighted and the isFancy parent state value is false. In the right section of the diagram, the isFancy parent state value has changed to true and it is highlighted in yellow, and so is the props bubble below, which has also changed its isFancy value to true."
/>

`App`의 상태를 바꾸는 것은 `Counter`를 초기화하지 않습니다. `Counter`가 항상 같은 위치에 있기 때문입니다.

같은 위치에 같은 컴포넌트가 있다면, React에 관점에서는 같은 카운터입니다.

:::danger 주의사항
**중요한건 JSX 마크업에서의 위치가 아니라 UI 트리에서의 위치임을 기억하세요! React에게는 굉장히 중요한 부분입니다.**
아래 컴포넌트는 두개의 `return`문이 있고 서로 다른 `<Counter />` JSX 태그가 `if`문 안과 밖에 위치해 있습니다.

<Code src="https://codesandbox.io/embed/weathered-monad-omf2o9?fontsize=14&hidenavigation=1&theme=dark" />

아마 여러분은 체크박스를 클릭했을 때 상태가 초기화된다고 생각했을 수도 있습니다. 하지만 그렇지 않습니다! 이는 **두 `<Counter />` 태그가 같은 위치에서 렌더링 되기 때문**입니다.
React는 여러분이 함수 어디서 조건문을 섰는지를 모릅니다. React가 보는 것은 오직 함수가 리턴하는 것입니다.
두가지 상황에서 `App` 컴포넌트는 `<div>`와 함께 `<Counter />`를 첫 번째 자식으로 리턴합니다. 그렇기 때문에 React가 이들을 _같은_ `<Counter />`로 보는 것입니다.

같은 "주소"을 가지고 있다고 생각해볼 수도 있습니다. root의 첫 번째 자식의 첫 번째 자식처럼 말이죠.
이는 React가 여러분이 작성한 함수의 로직과 관계 없이 이전 렌더링과 다음 렌더링을 연결시키는 방법이기도 합니다.
:::


## 같은 위치에 다른 컴포넌트가 들어오면 상태가 초기화 됩니다.

아래 예시에서, 체크박스를 클릭하면 `<Counter>`가 `<p>`로 바뀝니다.

<Code src="https://codesandbox.io/embed/zealous-mountain-ti7i1q?fontsize=14&hidenavigation=1&theme=dark" />

여기서 여러분은 같은 위치에서 서로 _다른_ 타입의 컴포넌트로 바꿨습니다. 처음에는 `<div>`의 첫번째 자식이 `<Counter />`를 포함했습니다.
하지만 `p`로 바뀐 이후에는 React가 `Counter`를 UI 트리에서 제거했고 상태도 제거했습니다.

<CenterImage
    src="https://beta.reactjs.org/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_pt1.dark.png&w=1920&q=75"
    alt="Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'Counter' containing a state bubble labeled 'count' with value 3. The middle section has the same 'div' parent, but the child component has now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'p', highlighted in yellow."
/>

`Counter`가 `p`로 바뀔때, `Counter`는 이줘지고 `p`가 추가됩니다.

<CenterImage
    src="https://beta.reactjs.org/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_pt2.dark.png&w=1920&q=75"
    alt="Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'p'. The middle section has the same 'div' parent, but the child component has now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, highlighted in yellow."
/>

다시 체크박스를 해제하면, `p`가 삭제되고 `Counter`가 추가됩니다.

또한 **같은 위치에 다른 컴포넌트를 렌더링 하려 한다면, React는 그 전체 서브트리의 상태도 함께 초기화시킵니다.**
아래 예시에서 카운터를 올린 후 체크박스를 클릭해 보세요.

<Code src="https://codesandbox.io/embed/keen-tharp-zo8qbe?fontsize=14&hidenavigation=1&theme=dark" />

카운터 상태는 여러분이 체크박스를 클릭했을때 초기화 되었습니다. 여러분이 렌더링 한 것은 `Counter`일지라도 `div`는 `div`에서 `section`으로 바뀌었습니다.
만약 `div`의 자식이 DOM에서 삭제되었다면, `Counter`와 그 상태를 포함한 전체 자식 트리도 함께 삭제됩니다.

<CenterImage
    src="https://beta.reactjs.org/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt1.dark.png&w=1920&q=75"
    alt="Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'section', which has a single child labeled 'Counter' containing a state bubble labeled 'count' with value 3. The middle section has the same 'div' parent, but the child components have now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'div', highlighted in yellow, also with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, all highlighted in yellow."
/>

만약 `section`이 `div`로 바뀌면 `section`이 삭제되고 새로운 `div`가 추가됩니다.

<CenterImage
    src="https://beta.reactjs.org/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt2.dark.png&w=1920&q=75"
    alt="Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'div', which has a single child labeled 'Counter' containing a state bubble labeled 'count' with value 0. The middle section has the same 'div' parent, but the child components have now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'section', highlighted in yellow, also with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, all highlighted in yellow."
/>

다시 되돌리게 되면 `div`가 삭제되고 새로운 `section`이 추가됩니다.

경험에 비추어 볼때, **리렌더링 되는 사이에도 상태를 유지하려고 한다면, 렌더링되는 트리의 구조는 "같아야"**합니다.
만약 구조가 다르다면, React가 컴포넌트를 트리에서 제거하면서 상태도 같이 파괴되기 때문입니다.

:::danger 주의사항
이는 중첩된 컴포넌트 함수를 사용해서는 안되는 이유이기도 합니다.

아래 예시에서 `MyTextField` 컴포넌트는 `MyComponent` _내부에_ 정의되어 있습니다.

<Code src="https://codesandbox.io/embed/festive-swartz-huufo3?fontsize=14&hidenavigation=1&theme=dark" />

버튼을 클릭할때마다 여러분의 입력값은 사라집니다!
이는 서로 다른 `MyTextField` 함수가 매 렌더링마다 `MyComponent` 내부에 새로 생성되기 때문입니다. 즉 매 렌더링마다 _다른_ 컴포넌트를 같은 위치에서 보여주고 있는 것입니다.
따라서 React는 모든 아래의 상태를 초기화합니다. 이는 버그와 성능 문제로 이어질 수 있습니다.
이 문제를 해결하기 위해서는 **항상 컴포넌트 함수를 최상위 레벨에 선언하고, 중첩되게 하지 않아야 합니다.**
:::

## 같은 위치에서 상태 초기화 하기

기본적으로, React는 컴포넌트가 같은 위치에 계속 있을 경우 상태를 유지합니다. 보통은 이게 여러분이 기대하는 대로 동작하다보니 기본값이지만,
가끔은 컴포넌트의 상태를 초기화 하고 싶을 수 있습니다. 아래 애플리케이션은 두명의 플레이어가 각 턴마다 그들의 점수를 기록하고 있습니다.

<Code src="https://codesandbox.io/embed/keen-mendeleev-cc3i15?fontsize=14&hidenavigation=1&theme=dark" />

지금은 플레이어를 바꿔도 점수가 유지됩니다. 두개의 `Counter`가 같은 위치에 나타나기 때문에 `person`이 달라졌더라도 React는 그 카운터들을 같은 컴포넌트로 봅니다.

그러나 개념적으로 그 두개의 카운터는 별개입니다. 같은 위치에서 그려지더라도 하나는 Taylor의 것, 그리고 또 다른 하나는 Sarah의 것이죠.

이럴땐 두 가지 방법으로 카운터가 전환될때 상태를 초기화 하도록 할 수 있습니다.
1. 컴포넌트를 다른 위치에서 그리도록 합니다.
2. 각 컴포넌트에게 특별한 `key` 속성을 부여합니다.

### 방법1 : 컴포넌트를 다른 위치에서 그린다.

만약 그 두개의 `Counter`를 독립된 것처럼 그리고 싶다면 그 둘을 다른 위치에 두면 됩니다.

<Code src="https://codesandbox.io/embed/affectionate-pine-hp1vxq?fontsize=14&hidenavigation=1&theme=dark" />

- `isPlayerA`는 처음에 `true` 였습니다. 그래서 첫번째 위치는 `Counter`를 포함하고 있고, 두번째는 비게 됩니다.
- 만약 "Next player" 버튼을 클릭하면 첫번째 위치가 비게 되고 이번엔 두번째가 `Counter`를 포함하게 됩니다.

<BlockQuote>각각의 `Counter`의 상태는 DOM으로부터 제거되었을때 함께 사라집니다. 이로 인해 버튼을 클릭할때마다 상태가 초기화됩니다.</BlockQuote>

이 방법은 적은 수의 독립된 컴포넌트를 같은 위치에 그리고자 할 때 유용합니다.
이 예시에서는 오직 두개의 컴포넌트만 그려야 하기 때문에 JSX로 이들을 각각 표현하는게 그렇게 어려운 일이 아닙니다.

### 방법2 : key를 통해 상태를 초기화하기

다른 방법도 있습니다. 컴포넌트의 상태를 초기화하는데 있어서 더 일반적인 방법입니다.

아마 [리스트를 렌더링](https://beta.reactjs.org/learn/rendering-lists#keeping-list-items-in-order-with-key)할 때 `key`를 본 적이 있을겁니다.
Key는 오직 리스트만을 위한 것이 아닙니다! key는 React가 컴포넌트를 구분할 수 있게 도와줍니다. 기본적으로 React는 컴포넌트를 '부모의 n번째 자식'처럼 순서를 부여해 구분합니다.
여기에 더해 key를 사용하면 React에게 '단순히 첫번째 자식은 아님'이라는 정보를 추가로 전해줄 수 있습니다.
예를 들어, '_Taylor_의 카운터' 같은 정보 말이죠. 그러면 React는 이 컴포넌트가 트리 어디에 있던 상관 없이 _Taylor_의 카운터임을 알 수 있습니다.

아래 예시에서 두개의 `<Counter />`는 같은 위치에서 렌더링되지만 상태를 공유하지는 않습니다.

<Code src="https://codesandbox.io/embed/keen-mendeleev-cc3i15?fontsize=14&hidenavigation=1&theme=dark" />

Taylor와 Sarah의 카운터를 전환해도 상태는 유지되지 않습니다. **서로 다른 `key`를 준 덕분입니다.**

```jsx
{isPlayerA ? (
  <Counter key="Taylor" person="Taylor" />
) : (
  <Counter key="Sarah" person="Sarah" />
)}
```

`key`를 특정짓는 것은 React에게 이 컴포넌트가 '부모의 n번째 자식'이라는 정보 대신 `key`를 위치 정보의 일부로 사용하라는 명령을 내리는 것입니다.
이로 인해 같은 컴포넌트를 같은 JSX 위치에 표현하더라도, React에 관점에서도 둘은 다른 컴포넌트로 보여지게 됩니다.
결과적으로 그 컴포넌트들은 상태를 절대 공유하지 않게 됩니다. 카운터가 매번 스크린에 나타날 때마다 상태는 새로 생성됩니다. 컴포넌트가 삭제될때마다 상태도 함께 삭제됩니다.
컴포넌트를 껐다 켜는 것은 상태를 계속 초기화 하는것과 같습니다.

<BlockQuote>key는 전역적으로 유일해야 될 필요는 없습니다. _같은 부모 밑에서 자식들 간에만_ 유일하면 됩니다.</BlockQuote>

## Key를 통해 form 초기화하기

Key를 이용해 상태를 초기화 하는 방법은 특히 form을 다룰때 유용합니다.

아래는 채팅 앱입니다. `<Chat>` 컴포넌트는 텍스트 입력창을 가지고 있습니다.

<Code src="https://codesandbox.io/embed/focused-maxwell-qssvz0?fontsize=14&hidenavigation=1&theme=dark" />

아무 메시지나 입력하고 "Alice"나 "Bob"을 선택해 누가 메시지를 받을지 선택해보세요. 입력된 상태가 유지되고 있음을 눈치 채셨나요?
`<Chat>`이 UI 트리의 같은 위치에 계속 있기 때문입니다.

**많은 앱들에서 이건 보통 요구되는 동작일 겁니다. 그치만 이 앱에서는 아닙니다!** 본의아니게 이미 입력된 메시지가 다른 사람에게 보내지는걸 바라지 않는다고 가정해봅시다.
이걸 고치기 위해서 `key`를 추가합니다.

```jsx
<Chat key={to.id} contact={to} />
```

이 코드를 추가함으로 인해 수신자를 바꾸게 될 경우 `Chat` 컴포넌트는 처음부터 새로 만들어짐을 보장받을 수 있습니다.
트리 구조에서 이 컴포넌트 아래에 있는 어떤 상태가 되었든 말이죠. React는 또한 DOM 엘리먼트를 재사용하는 대신에 새로 만들게 됩니다.

이제 다시 수신자를 바꿔봅시다. 텍스트 필드는 항상 깨끗하게 초기화됩니다.

<Code src="https://codesandbox.io/embed/jovial-pine-pj2njy?fontsize=14&hidenavigation=1&theme=dark" />


:::info DEEP DIVE

### 지워진 컴포넌트에서 상태 유지하기

실제 채팅 앱에서는 아마 이전 수신자를 다시 선택할 경우 그 때 입력했던 내용이 되살아나길 바랄겁니다.
컴포넌트가 사라지더라도 상태가 계속 "살아있게" 만드는 방법이 몇가지 있습니다.

- 현재 채팅 내용만 렌더링 하는 것이 아닌, _모든_ 채팅 내용을 렌더링 합니다. 대신 다른 내용들은 CSS로 숨기는 처리를 추가합니다. 다른 채팅들은 트리에서 지워지지만 지역 상태는 유지됩니다.
이 방법은 간단한 UI에서는 잘 동작합니다. 하지만 거대하고 수많은 DOM 노드들을 다뤄야 할때는 성능 면에서 좋은 방법이 아닐 수 있습니다.
- 각 수신자에게 보내지기 전 대기중인 메시지들을 부모 컴포넌트의 [상태를 올리는](https://beta.reactjs.org/learn/sharing-state-between-components) 방법이 있습니다.
마찬가지로 이 방법에서도 자식 컴포넌트가 지워지더라도 상태는 유지됩니다. 부모 컴포넌트가 모든 중요한 정보들을 갖고 있습니다. 그리고 가장 흔한 방법입니다.
- React state와 별개의 저장소를 이용하는 방법이 있습니다. 갑자기 페이지가 닫히더라도 메시지 초안이 사라지지 않도록 하는 처리를 해야 한다고 가정해 봅시다.
이를 구현하기 위해서는 `Chat` 컴포넌트가 [`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)로부터 데이터를 읽어와 상태에 저장해야 합니다.
초안 데이터들도 여기 저장하구요.

어떤 전략을 선택하든, _Alice_와의 채팅은 개념적으로 _Bob_의 채팅과 구분되어야 합니다. 그래서 현재 수신자를 기준으로 `<Chat>`에 `key`를 주는 선택이 타당합니다.
:::

## 되짚어보기
- React는 같은 컴포넌트가 같은 위치에서 렌더링되는 한 상태를 유지합니다.
- 상태는 JSX 태그에 저장되는 것이 아닙니다. 상태는 UI 트리에서 어떤 위치에 JSX를 집어넣는지에 연관이 있습니다.
- key를 다르게 주는 방법을 통해 강제로 서브트리가 상태를 초기화하도록 할 수 있습니다.
- 컴포넌트 정의를 중첩되게 하지 마세요. 의도치 않게 상태가 초기화되는 일이 발생할 수도 있습니다.


:::note 도전해보기

### 도전1. 사라지는 텍스트 입력창 고치기

아래 예시에서는 버튼을 클릭하면 메시지를 보여줍니다. 하지만 의도치 않게 버튼을 누르는 동작이 입력창을 초기화 하기도 합니다.
왜 그럴까요? 버튼을 눌러도 입력창이 초기화되지 않도록 고쳐보세요.

<Code src="https://codesandbox.io/embed/fervent-brattain-ewwi95?fontsize=14&hidenavigation=1&theme=dark" />

**정답**
문제는 `Form`이 다른 위치에서 렌더링 된다는 것입니다. `if` 조건문에서 `Form`은 `<div>`의 두번째 자식이지만 `else` 문에서는 첫번째 자식입니다.
그래서 위치에 따라 다른 두 컴포넌트에서 서로 다른 입력을 하고 있던 것입니다.
첫번째 위치는 `p`와 `Form`을 포함하고 있지만 두번째 상태는 `Form`과 `button`을 포함한 상태입니다. React는 컴포넌트 타입이 바뀔때마다 상태를 초기화합니다.

가장 쉬운 방법은 조건문을 통합해 `Form`이 항상 같은 위치에 있도록 만드는 것입니다.

<Code src="https://codesandbox.io/embed/focused-silence-gsl74e?fontsize=14&hidenavigation=1&theme=dark" />

기술적으로는 `else` 문도 `if`문과 같아지도록 `<Form />` 이전에 `null`을 추가할 수도 있습니다.

<Code src="https://codesandbox.io/embed/lingering-architecture-1putd8?fontsize=14&hidenavigation=1&theme=dark" />

이 방법을 이용하면 `Form`은 항상 두번째 자식이 됩니다. 그래서 항상 같은 위치에 있게 되고 상태를 유지할 수 있습니다.
그치만 이 방법은 누군가 `null`을 지운다면 위험해질 수 있는 방법입니다.


### 도전2. 두개의 form 필드 바꾸기

이 form은 성과 이름을 입력으로 받습니다. 또한 체크박스를 통해 어떤 필드를 먼저 입력받을지 정할 수 있습니다.
체크박스를 체크하면 "Last name" 필드는 "First name" 필드보다 먼저 보여지게 됩니다.

대부분 원하는대로 동작하지만, 버그가 하나 있습니다. 만약 "First name" 필드를 입력하고 체크박스를 클릭하면 여러분이 입력한 내용이 첫번째 입력창에 남게 됩니다
(이제 그 영역은 성을 입력하는 곳인데 말이죠).
입력창의 순서가 바뀔때 입력된 내용도 함께 바뀌도록 코드를 수정해보세요.

<Code src="https://codesandbox.io/embed/wonderful-jepsen-wvuf1s?fontsize=14&hidenavigation=1&theme=dark" />

**힌트**
부모로부터의 위치 정보만으로는 부족할것 같습니다. 리렌더링이 발생하더라도 React가 상태를 연결시킬 수 있도록 하는 방법이 있을까요?

**정답**
`if`문과 `else`문에 있는 두 `<Field>` 컴포넌트에게 `key`를 부여합시다.
이는 부모로부터의 순서가 바뀌더라도 React가 어떻게 상태를 알맞은 `<Field>` 에게 "매치시킬 수 있는지" 알려줍니다.

<Code src="https://codesandbox.io/embed/still-flower-iqbeyr?fontsize=14&hidenavigation=1&theme=dark" />


### 도전3. 상세 form 초기화하기

아래는 수정 가능한 연락처 리스트입니다. "Save"를 눌러 연락처의 세부 정보를 업데이트 할 수도 있고, "Reset"을 눌러 입력한 내용을 되돌릴 수도 있습니다.

만약 다른 연락처를 선택했다면 상태는 업데이트 되지만 form은 이전 연락처의 정보를 계속 보여주고 있습니다.
선택된 연락처가 변경되었을 때 form의 내용이 초기화될 수 있도록 고쳐보세요.

<Code src="https://codesandbox.io/embed/withered-paper-6ic03d?fontsize=14&hidenavigation=1&theme=dark" />

**정답**
`key={selectedId}`를 `EditContact` 컴포넌트에게 부여합니다. 이를 통해 다른 연락처로 이동할 때 form을 초기화 할 수 있습니다.

<Code src="https://codesandbox.io/embed/focused-ully-q4266x?fontsize=14&hidenavigation=1&theme=dark" />


### 도전4. 로딩중일때 이미지 숨기기

"Next" 버튼을 누를 경우 브라우저는 다음 이미지를 로드하기 시작합니다.
하지만 기본적으로 새 이미지는 이전과 같은 `<img>` 태그에 보여지기 때문에 다음 이미지가 로드되는 동안에도 여전히 이전 이미지를 계속 보고 있게 됩니다.
항상 하단의 텍스트가 이미지와 매치되어야 한다면 지금의 동작 방식은 여러분이 원하는 것과는 다를 겁니다.
"Next" 버튼을 눌렀을 때 이미지가 즉시 사라지도록 바꿔보세요.

<Code src="https://codesandbox.io/embed/hungry-nightingale-n28pzm?fontsize=14&hidenavigation=1&theme=dark" />

**힌트**
React에게 DOM을 재사용하지 말고 새로 만들도록 하는 방법이 있었죠?

**정답**
`<img>` 태그에게 `key`를 부여하면 됩니다. `key`가 바뀌면 React는 `<img>` DOM 노드를 처음부터 새로 만들 것입니다.
이는 이미지가 로드되는 과정에 약간의 화면 깜빡거림을 만들기 때문에 앱의 모든 이미지에 대해 이런 동작이 일어나길 바라진 않겠지만,
꼭 이미지가 텍스트와 매치되어야 한다면 괜찮은 방법입니다.

<Code src="https://codesandbox.io/embed/reverent-heyrovsky-2px9i4?fontsize=14&hidenavigation=1&theme=dark" />


### 도전5. 리스트에서 잘못 배치된 상태 고치기

리스트에서 각 `Contact`는 "Show email" 버튼이 눌렸는지 여부를 저장하는 상태를 가족 있습니다.
Alice의 "Show email" 버튼을 클릭한 후 "Show in reverse order" 체크박스를 클릭해보세요.
그러면 아마 _Taylor_의 이메일이 보여지고 있고, Alice의 이메일은 보여지지 않고 있음을 확인할 수 있을 것입니다. 맨 밑으로 가면서 이메일이 숨김 처리 되었습니다.

이메일 노출 여부를 다루는 상태가 순서와는 상관 없이 각 연락처와 연결되도록 수정해보세요.

<Code src="https://codesandbox.io/embed/frosty-agnesi-j7swnf?fontsize=14&hidenavigation=1&theme=dark" />

**정답**
문제는 index를 `key`로 사용한다는 것입니다.

```jsx
{displayedContacts.map((contact, i) =>
  <li key={i}>
```

그치만 우리가 원하는 것은 상태가 _특정한_ 연락처와 연결되는 것이죠.

index 대신 연락처 ID를 `key`로 활용하면 문제를 고칠 수 있습니다.

<Code src="https://codesandbox.io/embed/infallible-violet-gv3nrq?fontsize=14&hidenavigation=1&theme=dark" />

상태는 트리에서의 위치에 연관됩니다. `key`는 상태가 순서에 의존하지 않고 특정한 이름에 대해 연결될 수 있도록 돕습니다.

:::