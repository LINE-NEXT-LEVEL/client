import {Code} from "../../../src/components/Code";
import {BlockQuote} from "../../../src/components/BlockQuote";
import {Challenge, DetailButton} from '../../../src/components/Challenge;

# 상태 로직을 Reducer로 추출하기

많은 이벤트 헨들러에 걸친 상태 업데이트를 갖고 있는 컴포는터는 과부하가 걸릴 수 있습니다. 이러한 경우들을 위해, 컴포넌트 밖에서 _reducer_라고 불리는 함수 하나를 통해 모든 상태 업데이트 로직을 통합할 수 있습니다. 

:::note you will learn
- reducer 함수가 무엇인지
- `useState`을 `useReducer`로 리펙토링하는 방법
- reducer를 사용할 때
- reducer를 잘 작성하는 방법
:::

## reducer로 상태 로직을 통합하기

컴포넌트들의 복잡도가 높아질수록, 컴포넌트들이 업데이트되는 모든 다양한 방식들을 살펴보기는 더욱 더 힘들어집니다. 예를 들어, 아래의 `TaskApp` 컴포넌트는 `tasks` 배열을 상태로 갖고 있고, tasks를 추가하고, 제거하고, 수정하기 위한
세 개의 다른 이벤트 핸들러를 사용합니다. 

<Code src="https://codesandbox.io/s/yrv1mz?file=/App.js&utm_medium=sandpack"/>

각각의 이벤트 핸들러들은 상태를 업데이트하기 위해 `setTasks`를 부릅니다. 컴포넌트가 커질 수록, 컴포넌트 전체에 뿌려져 있는 상태 로직의 양도 증가합니다. 
복잡도를 줄이고 모든 로직을 모든 로직을 하나의 접근하기 편한 장소에 유지하기 위해서, **"reducer""라고 불리는 컴포넌트 밖의 하나의 함수에 상태 로직을 옮길 수 있습니다.

Reducer들은 상태를 관리하기 위한 다른 방법입니다. 세 가지 스텝들을 거쳐 `useState`에서 `useReducer`으로 변경할 수 있습니다. 

1. 상태를 설정하는 것에서 액션을 디스패치하는 것으로 **옮기세요.**
2. 리듀서 함수를 **작성하세요.**
3. 컴포넌트에서 리듀서를 **사용하세요.**

## 1단계: 상태를 설정하는 것에서 액션을 디스패치하기

현재 있는 이벤트 헨들러들은 상태를 설정해서 무엇을 할지를 명시합니다.

```js
function handleAddTask(text) {
  setTasks([
    ...tasks,
    {
      id: nextId++,
      text: text,
      done: false,
    },
  ]);
}

function handleChangeTask(task) {
  setTasks(
    tasks.map((t) => {
      if (t.id === task.id) {
        return task;
      } else {
        return t;
      }
    })
  );
}

function handleDeleteTask(taskId) {
  setTasks(tasks.filter((t) => t.id !== taskId));
}
```

로직을 설정하는 모든 관계를 제거하세요. 남은 것은 세 개의 이벤트 핸들러입니다:

- `handleAddTask(text)`는 사용자가 "Add"를 누르면 호출됩니다.
- `handleChangeTask(task)`는 사용자가 테스크를 올리거나 "Save"를 누르면 호출됩니다.
- `handleDeleteTask(taskId)`는 사용자가 "Delete"을 누르면 호출됩니다.

리듀서로 상태를 관리하는 것은 상태를 바로 설정하는 것과는 미묘하게 다릅니다. 상태를 설정해서 React에게 "무엇을 할지" 말하는 것 대신에, 이벤트 핸들러에서 "액션들"을 보내서 "사용자가 방금 무엇을 했는지"를 명시하는 것입니다.
(로직을 업데이트하는 상태는 어딘가에 살아있을 것입니다!) 그래서 "`테스크들`를 설정하는 것" 대신에 이벤트 핸들러를 통해, "테스크를 추가했고/변경했고/삭제했다"는 행동을 보낼 것입니다. 
이것이 사용자의 의도를 더 잘 묘사합니다.

```
function handleAddTask(text) {
  dispatch({
    type: 'added',
    id: nextId++,
    text: text,
  });
}

function handleChangeTask(task) {
  dispatch({
    type: 'changed',
    task: task,
  });
}

function handleDeleteTask(taskId) {
  dispatch({
    type: 'deleted',
    id: taskId,
  });
}
```

`dispatch`에 전달하는 객체를 "action"이라고 부릅니다:

```js
function handleDeleteTask(taskId) {
  dispatch(
    // "action" object:
    {
      type: 'deleted',
      id: taskId,
    }
  );
}
```

이것은 일반적인 JavaScript 객체입니다. 무엇을 넣을지 결정할 수 있지만, 일반적으로 _무엇이 일어났는지_에 대해서는 최소한의 정보를 가져야 합니다. (다음 단계에서 `dispatch` 함수를 추가할 것입니다.)

:::note Note 
action 객체는 어떠한 모양도 가질 수 있습니다. 

관례에 따르면, 무엇이 일어났는지를 묘사하는 string `type`을 주는 것이 흔하고, 다른 필드에 어떤 추가적인 정보를 전달 할 수도 있습니다. 
`type`은 한 컴포넌트에 특정되는 것이기 떄문에 이 경우에는 `added` 혹은 `added_task` 중 하나가 적당해 보입니다. 어떤 일이 일어났는지를 말해주는 이름을 선택하세요! 

```js
dispatch({
  // specific to component
  type: 'what_happened',
  // other fields go here
});
```
:::

## 2단계 : reducer 함수 작성하기

리듀서 함수는 상태 로직을 넣는 위치입니다. 현재의 상태와 action 객체, 두 개의 인자를 받고 다음 상태를 되돌려줍니다:

```js
function yourReducer(state, action) {
  // return next state for React to set
}
```

React 는 reducer에서 리턴되는 것을 상태로 설정할 것입니다. 

상태 로직을 이벤트 핸들러에서 reducer 함수로 옮기기 위해서 이번 예제에서는, 여러번은 이것들을 할 것입니다:

1. 첫 번째 인자로 현재의 상태(`task`)를 선언하세요.
2. 두 번째 인자로 `action` 객체를 선언하세요.
3. reducer 에서 _다음_ 상태를 리턴하세요. (React가 상태로 설정할 것)

여기 reducer 함수로 이동한 상태 설정 로직이 있습니다:

```js
function tasksReducer(tasks, action) {
  if (action.type === 'added') {
    return [
      ...tasks,
      {
        id: action.id,
        text: action.text,
        done: false,
      },
    ];
  } else if (action.type === 'changed') {
    return tasks.map((t) => {
      if (t.id === action.task.id) {
        return action.task;
      } else {
        return t;
      }
    });
  } else if (action.type === 'deleted') {
    return tasks.filter((t) => t.id !== action.id);
  } else {
    throw Error('Unknown action: ' + action.type);
  }
}
```

<BlockQuote>
reducer 함수는 상태(task)를 인자로 받기 때문에, 컴포넌트 밖에 그 인자를 선언해야 합니다. 이렇게 하면 들여쓰기 깊이도 줄어들고 코드도 더 쉽게 읽히도록 만들 수 있습니다.
</BlockQuote>


:::note Note

위의 코드는 if/else 구문을 사용합니다. 하지막 관례는 reducer 안에 [switch 구문](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/switch) 을 사용하는 것입니다.
결과는 같지만 한 눈에 보기에 switch 구문이 더 읽기 쉽습니다.

이 글의 나머지에서는 다음과 같이 구문을 사용할 것입니다. 

```js
function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case 'changed': {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```
각각의 `case`를 `{`와`}`인 중괄호로 감싸는 것을 추천합니다. 다른 `case`의 안에 선언된 변수들이 서로 부딪히지 않도록 하기 위함임니다. 또한, 한 `case`도 보통 `return`으로 끝나야 합니다. 만약 `return`하는 것을 잊는다면, 
코드는 다음 `case`로 "통과해 떨어져서", 실수로 이어질 수 있습니다!

만약 아직 switch 구문에 익숙하지 않다면 대신 if/else를 사용해도 완전히 무방합니다.
:::

:::info Deep Dive
### 왜 reducer는 이러한 방식으로 불리는 것일까요?
 reducer는 컴포넌트 안ㅔ 코드의 양을 "줄일" 수 있지만, 사실 배열에서 수행 수  있는 reduce() 작업에서 이름지어졌습니다. 

 reduce()를 실행하면 배열을 받고 다양한 값들 중 하나의 값을 "축적"합니다:

 ```js
 const arr = [1, 2, 3, 4, 5];
const sum = arr.reduce(
  (result, number) => result + number
); // 1 + 2 + 3 + 4 + 5
 ```

`reduce`를 통해 전달한 함수는 "reducer"로 알려져 잇습니다. 이 함수는 이 때까지의 _결과_와 _현재 요소_를 받고나서 _다음 결과_를 리턴해줍니다. React의 reducer 또한 같은 생각의 한 예입니다: 
_이 때까지의 상태_를 받고 _다음 결과_를 리턴해줍니다. 이러한 방법으로, 상태에 action들을 축적합니다.

심지어 reducer 함수에 넘겨서 최종 상태를 계산하기 위해 `initialState`와 `action`들의 배열로 `reduce()` 메소드를 사용할 수 있습니다:

<Code src="https://codesandbox.io/s/ogkvy1?file=/index.js&utm_medium=sandpack"/>
<Code src="https://codesandbox.io/s/ogkvy1?file=/tasksReducer.js&utm_medium=sandpack"/>
<Code src="https://codesandbox.io/s/ogkvy1?file=%2Fpublic%2Findex.html&utm_medium=sandpack"/>

아마 이걸 직접 할 필요는 없을 것이지만, 이렇게 하면 React가 하는 방식과 비슷합니다!

:::

## 3단계: 컴포넌트에서 reducer 사용하기 

마지막으로, `tasksReducer`를 컴포넌트에 연결해야합니다. React에서 `useReducer` 훅을 꼭 import 하세요.
```js
import {useReducer} from 'react';
```

그리고 나서 `useState`를 대체할 수 있습니다:
```js
const [tasks, setTasks] = useState(initialTasks);
```

`useReducer`로도 그렇게 가능합니다:
```js
const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
```

`useReducer` 훅은 `useState`와 비슷합니다. - 초기 상태를 전달해야하고 useReducer가 상태로 쓰이는 값과 그 상태를 설정하는 방법을 돌려줍니다( 이 경우에는 dispatch 함수입니다). 
하지만 조금 다른 부분이 있습니다 .

`useReducer` 훅은 두개의 인자를 받습니다:

1. 하나의 reducer 함수
2. 하나의 초기 상태

이제 완전히 이어졌습니다! 여기서 reducer는 컴포넌트 파일의 아래에 선언되어있습니다:

<Code src="https://codesandbox.io/s/eueycz?file=%2FApp.js&utm_medium=sandpack"/>

원하면 다른 파일로 reducer를 이동시킬 수도 있습니다:

<Code src="https://codesandbox.io/s/3uuhkl?file=%2FApp.js&utm_medium=sandpack"/>

컴포넌트 로직은 이렇게 책임을 분리하면 더 쉽게 읽을 수 있습니다. 이제 이벤트 핸들러는 action을 보내어 _무엇이 일어났는지_를 명시하고, reducer 함수는 그게 반응하여 _어떻게 상태를 업데이트 하는지_를 결정합니다.

## `useState`와 `useReducer`를 비교하기 

Reducer가 불리한 면이 없는 것은 아닙니다! 아래에 두 가지를 비교할 몇 가지 방법을 제시했습니다:

**코드 크기**: 일반적으로, `useState`로는 솔직하게 더 적은 코드를 작성할 수 있습니다. `useReducer`로는 reducer함수_와_ action을 두 다 보내야 합니다. 그러나, `useReducer`는 만약 비슷한 방식의 상태를 
수정하는 많은 이벤트 핸들러들이 있다면 코드를 줄일 수 있습니다.

**가독성**: `useState`는 상태 업데이트가 간단하다면 정말 읽기 쉽습니다. 업데이트가 복잡해진다면 코드가 점점 더 부풀려져서 읽어내기 어렵게 될 것입니다.
이 경우에, `useReducer`는 이벤트 핸들러의 _무엇이 일어났는지_에서 _어떻게_ 상태를 업데이트하는 지를 깔끔하게 분리할 수 있습니다. 

**디버깅**: `useState`로 버그가 있으면 _어디서_ 그리고 _왜_ 상태가 부정확하게 설정되었는지 말하기 어려울 수 있습니다. 
`useReducer`를 사용하면, 리듀서에 콘솔 로그를 포함해서 모든 상태 업데이트를 보고, _왜_ 그것이 일어났는지 (어떤 `action` 때문인지)를 볼 수 있습니다. 
만약 각 `action`이 정확하다면, reducer 로직 그 자체에 실수가 있었다는 것을 알 수 있을 것입니다. 그러나, `useState`를 사용할 떄는 코드를 파헤치기 위해 더 많은 절차를 밟아야 합니다.

**테스트**: reducer는 컴포넌트에 의존하지 않는 순수함수 입니다. 이것은 export 해서 독립된 곳에서 테스트할 수 있다는 것을 의미합니다. 
일반적으로 더 현실적인 환경에서 컴포넌트를 테스트하는 것이 가장 좋지만, 복잡한 상태 업데이트 로직에서는 reducer가 특정 초기값과 action에 특정한 상태를 되돌려주는 것을 확실히하는 것이 더 유용합니다.

**개인의 선호**: 어떤 사람은 reducer를 좋아하고, 어떤 사람은 그렇지 않습니다. 괜찮습니다. 선호의 문제일 뿐이죠. 항상 `useState`와 `useReducer`를 번갈아가면서 사용해도 됩니다: 둘은 동등합니다!

우리는 컴포넌트에서 부정확한 상태 업데이트 떄문에 버그를 자주 마주하게 된다면 reducer를 사용하기를 추천하고 코드를 더 구조화시키는 것을 원합니다. 모든 것에 reducer를 사용할 필요는 없습니다: 자유롭게 섞어 쓰세요!
심지어 같은 컴포넌트에 `useState`과 `useReducer`를 같이 써도 상관 없습니다. 

## reducer를 잘 작성하기

reducer를 쓸 때는 두 가지 팁을 머리 속에 기억하세요:

- **reducer는 순수해야 한다:** [상태 업데이트 함수](https://beta.reactjs.org/learn/queueing-a-series-of-state-updates)와  비슷하게, reducer는 렌더링 동안 돌아갑니다!
(Action은 다음 렌더링 때까지 쌓여있습니다.) 이것은 reducer가 반드시 [순수해야 한다](https://beta.reactjs.org/learn/keeping-components-pure)는 것을 의미합니다 - 같은 입력은 같은 결과를 낳아야 합니다.
요청을 보내거나, timeout을 계획하거나, (컴포넌트 밖의 어떤 것에 영향을 줄 수 있는 동작)어떠한 부작용을 만들어서도 안 됩니다. reducer는 [객체](https://beta.reactjs.org/learn/updating-objects-in-state)와 [배열](https://beta.reactjs.org/learn/updating-arrays-in-state)을 변경 없이 업데이트 해야만 합니다.

- **각 action은 데이터에서 다양한 변화를 일으킬 수 있더라도 하나의 사용자 인터랙선을 의미합니다.** 예를 들어, 만약 사용자가 reducer에 의해 관리되는 다섯 개의 입력 필드 형식의 "새로 고침"을 누른다면, 
다섯개의 각각의 `set_field` action을 보내는 것보다 하나의 `reset_form` action을 보내는 것이 더 합리적이다. 만약 모든 action을 reducer에 기록한다면, 로그는 어떤 인터랙션을 재구성할지 
혹은 어떤 순서로 반응이 일어났는지를 충분히 명확하게 보여주여야 한다. 이 부분은 debugging 하는데 도움이 된다!

## Immer를 사용해 정확한 reducer 쓰기

일반적인 상테에서 [*객체를 업데이트*](https://beta.reactjs.org/learn/updating-objects-in-state#write-concise-update-logic-with-immer)하고 [배열을](https://beta.reactjs.org/learn/updating-arrays-in-state#write-concise-update-logic-with-immer) 업데이트 하는 것처럼,
리듀서를 더 정확하게 만들기 위해 Immer 라이브러리를 사용할 수 있습니다. 여기에, `[useImmerReducer](https://github.com/immerjs/use-immer#useimmerreducer)`rk `push`또는 `arr[i]=` 할당을 통해 상태를 변경하도록 해줍니다:

<Code src="https://codesandbox.io/s/1kbqy4?file=%2FApp.js&utm_medium=sandpack"/> 

reducer는 반드시 순수해야 하기 때문에 상태를 변경시키면 안됩니다. 하지만 Immer는 안전하게 변경할 수 있는 특별한 `초안` 객체를 제공합니다. 
물 밑에서, Immer는 `초안`에 만든 변경 상태의 복사본을 만들 것입니다. 그렇기 때문에 `useImmerReudcer`로 관리되는 reducer들은 첫 번째 인자를 변경할 수 있고 상태를 반환하지 않아도 됩니다. 

## 되짚어보기

- `useState`에서 `useReducer`로 변경하기: 
  1. 이벤트 핸들러에서 action을 보내세요.
  2. 받은 상태와 action으로 다음 상태를 반환하는 reducer함수를 작성하세요.
  3. `useState`를 `useReducer`로 교체하세요.
- reducer는 코드를 더 많이 작성해야할 수는 있지만, 디버깅과 테스트를 도와줍니다.
- reducer는 순수해야 합니다.
- 변경하는 방식으로 reducer를 작성하고 싶다면 Immer를 사용하세요.

## 문제에 도전해보세요.  
<Challenge title="이벤트 핸들러에서 action 보내기" index={1}>
  현재, `ContactList.js`와`Chat.js`안의 이벤트 핸들러들은`// TODO`코멘트를 갖고 있습니다. 입력이 작동하지 않는 이유이고, 버턴 클릭이 선택된 받는 이를 바꾸지 않는 이유입니다.

  해당하는 action을 `dispatch`하기 위해 코드로 두`// TODO`를 교체하세요. 예상한 모양과 action의 종류를 보기 위해, `messengerReducer.js` 안의 reducer를 체크하세요. 
  reducer는 이미 작성되어 있어서 바꿀 필요는 없습니다. `ContactList.js`와`Chat.js`에서 action을 보내기만 하면 됩니다.

  <Code src="https://codesandbox.io/s/r279gj?file=%2FApp.js&utm_medium=sandpack"/>    
  <Flex>
  <DetailButton name="힌트"> 
  `dispatch`함수는 prop으로 전달되었기 때문에 컴포넌트에서 이미 이용할 수 있습니다. 
  그래서 해당하는 action 객체로 `dispatch`를 부를 필요가 있습니다.

  객체의 모양을 확인하기 위해, reducer를 보고 어떤 `action` 필드를 볼지 확인할 수 있습니다. 예를 들어, reducer안의 `changed_selection` 케이스는 이렇게 보일 수 있습니다:

  ```js
  case 'changed_selection': {
  return {
    ...state,
    selectedId: action.contactId
  };
}
  ```  
</DetailButton>
<DetailButton name="해답">
reducer 코드에서, 필요한 action이 이렇게 생겼다는 것을 유추할 수 있습니다:

```js
// When the user presses "Alice"
dispatch({
  type: 'changed_selection',
  contactId: 1,
});

// When user types "Hello!"
dispatch({
  type: 'edited_message',
  message: 'Hello!',
});
```

해당하는 메세지를 보내기 위해 업데이트된 예제가 있습니다:

<Code src="https://codesandbox.io/s/dmj309?file=/App.js&utm_medium=sandpack"/>
</DetailButton>
  </Flex>
</Challenge>

<Challenge title="메세지를 보낼 때 입력 초기화하기" index={2}>
현재, "보내기" 버튼을 누르는 것은 아무것도 하지 않습니다. 
이렇게 동작할 "보내기" 버튼에 이벤트 핸들러를 붙이세요:

1. 받는 이의 이메일과 메세지를 `alert`로 보여주세요.
2. 메세지 입력을 초기화하세요.

<Code src="https://codesandbox.io/s/dmj309?file=%2FChat.js&utm_medium=sandpack"/>
</Challenge>